//
// Created by fss on 22-6-10.
//
#ifndef TINYVCS_INCLUDE_CUUTILS_H_
#define TINYVCS_INCLUDE_CUUTILS_H_

#include <iostream>
#include <algorithm>
#include <numeric>
#include "cuda_runtime.h"
#include <NvInfer.h>

#define UNUSED(unusedVariable) (void)(unusedVariable)
// suppress compiler warning: unused parameter

inline int64_t volume(const nvinfer1::Dims &d) {
  return std::accumulate(d.d, d.d + d.nbDims, 1, std::multiplies<int64_t>());
}

inline unsigned int getElementSize(nvinfer1::DataType t) {
  switch (t) {
    case nvinfer1::DataType::kINT32: return 4;
    case nvinfer1::DataType::kFLOAT: return 4;
    case nvinfer1::DataType::kHALF: return 2;
    case nvinfer1::DataType::kINT8: return 1;
    default: throw std::runtime_error("Invalid DataType.");
  }
}

#ifndef CUDA_CHECK
#define CUDA_CHECK(callstr)                                                                    \
    {                                                                                          \
        cudaError_t error_code = callstr;                                                      \
        if (error_code != cudaSuccess) {                                                       \
            const char*err_msg=cudaGetErrorString(error_code);                                                                                       \
            std::cerr << "CUDA error "<<err_msg << error_code << " at " << __FILE__ << ":" << __LINE__ << std::endl; \
            exit(0);                                                                           \
        }                                                                                      \
    }
#endif

inline void *safeCudaMalloc(size_t memSize) {
  void *deviceMem;
  CUDA_CHECK(cudaMalloc(&deviceMem, memSize));
  if (deviceMem == nullptr) {
    std::cerr << "Out of memory" << std::endl;
    exit(1);
  }
  return deviceMem;
}

inline void safeCudaFree(void *deviceMem) {
  CUDA_CHECK(cudaFree(deviceMem));
}

#endif //TINYVCS_INCLUDE_CUUTILS_H_
